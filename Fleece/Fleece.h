//
// Fleece.h
//
// Copyright (c) 2016 Couchbase, Inc All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

#pragma once
#ifndef _FLEECE_H
#define _FLEECE_H

#include "FLSlice.h"

#ifdef __clang__
    #define FLNONNULL                     __attribute__((nonnull))
#else
    #define FLNONNULL
#endif


#ifdef __cplusplus
extern "C" {
#endif

    // This is the C API! For the C++ API, see FleeceCpp.hh.


    /** \defgroup Fleece Fleece
        @{ */

    /** \name Types and Basic Functions
        @{ */


    //////// TYPES

#ifndef FL_IMPL
    typedef const struct _FLValue* FLValue;         ///< A reference to a value of any type.
    typedef const struct _FLArray* FLArray;         ///< A reference to an array value.
    typedef const struct _FLDict*  FLDict;          ///< A reference to a dictionary (map) value.
    typedef struct _FLArray* FLMutableArray;        ///< A reference to a mutable array.
    typedef struct _FLDict*  FLMutableDict;         ///< A reference to a mutable dictionary.
    typedef struct _FLEncoder*     FLEncoder;       ///< A reference to an encoder
    typedef struct _FLSharedKeys*  FLSharedKeys;    ///< A reference to a shared-keys mapping
    typedef struct _FLKeyPath*     FLKeyPath;       ///< A reference to a key path
    typedef struct _FLDeepIterator* FLDeepIterator; ///< A reference to a deep iterator
#endif


    /** Types of Fleece values. Basically JSON, with the addition of Data (raw blob). */
    typedef enum {
        kFLUndefined = -1,  // Type of a NULL pointer, i.e. no such value, like JSON `undefined`
        kFLNull = 0,        // This is a non-NULL value, equivalent to a JSON 'null'
        kFLBoolean,
        kFLNumber,
        kFLString,
        kFLData,
        kFLArray,
        kFLDict
    } FLValueType;


    /** Output formats a FLEncoder can generate. */
    typedef enum {
        kFLEncodeFleece,
        kFLEncodeJSON,
        kFLEncodeJSON5
    } FLEncoderFormat;

    
    typedef enum {
        kFLNoError = 0,
        kFLMemoryError,        // Out of memory, or allocation failed
        kFLOutOfRange,         // Array index or iterator out of range
        kFLInvalidData,        // Bad input data (NaN, non-string key, etc.)
        kFLEncodeError,        // Structural error encoding (missing value, too many ends, etc.)
        kFLJSONError,          // Error parsing JSON
        kFLUnknownValue,       // Unparseable data in a Value (corrupt? Or from some distant future?)
        kFLInternalError,      // Something that shouldn't happen
        kFLNotFound,           // Key not found
        kFLSharedKeysStateError, // Misuse of shared keys (not in transaction, etc.)
    } FLError;

    /** @} */


    //////// VALUE


    /** \name Parsing And Converting Values
        @{ */

    /** Returns a reference to the root value in the encoded data.
        Validates the data first; if it's invalid, returns NULL.
        Does NOT copy or take ownership of the data; the caller is responsible for keeping it
        intact. Any changes to the data will invalidate any FLValues obtained from it. */
    FLValue FLValue_FromData(FLSlice data);

    /** Returns a pointer to the root value in the encoded data, _with only minimal validation_;
        or returns NULL if the validation failed.
        This is significantly faster than FLValue_FromData, but should only be used if the data was
        generated by a trusted encoder and has not been altered or corrupted. For example, this
        can be used to parse Fleece data previously stored in a local database, as long as the
        database record has some kind of integrity check like a CRC32.
        If invalid data is read by this call, subsequent calls to Value accessor functions can
        crash or return bogus results (including data from arbitrary memory locations.) */
    FLValue FLValue_FromTrustedData(FLSlice data);

    /** Directly converts JSON data to Fleece-encoded data.
        You can then call FLValueFromTrustedData to get the root as a Value. */
    FLSliceResult FLData_ConvertJSON(FLSlice json, FLError *outError);

    /** Produces a human-readable dump of the Value encoded in the data. */
    FLStringResult FLData_Dump(FLSlice data);

    /** Debugging function that returns a C string of JSON. Does not free the string's memory! */
    const char* FLDump(FLValue);
    /** Debugging function that returns a C string of JSON. Does not free the string's memory! */
    const char* FLDumpData(FLSlice data);

    /** @} */
    /** \name Value Accessors
        @{ */

    // Value accessors -- safe to call even if the value is NULL.

    /** Returns the data type of an arbitrary Value.
        (If the value is a NULL pointer, returns kFLUndefined.) */
    FLValueType FLValue_GetType(FLValue);

    /** Returns true if the value is non-NULL and represents an integer. */
    bool FLValue_IsInteger(FLValue);

    /** Returns true if the value is non-NULL and represents an _unsigned_ integer that can only
        be represented natively as a `uint64_t`. In that case, you should not call `FLValueAsInt`
        because it will return an incorrect (negative) value; instead call `FLValueAsUnsigned`. */
    bool FLValue_IsUnsigned(FLValue);

    /** Returns true if the value is non-NULL and represents a 64-bit floating-point number. */
    bool FLValue_IsDouble(FLValue);

    /** Returns a value coerced to boolean. This will be true unless the value is NULL (undefined),
        null, false, or zero. */
    bool FLValue_AsBool(FLValue);

    /** Returns a value coerced to an integer. True and false are returned as 1 and 0, and
        floating-point numbers are rounded. All other types are returned as 0.
        Warning: Large 64-bit unsigned integers (2^63 and above) will come out wrong. You can
        check for these by calling `FLValueIsUnsigned`. */
    int64_t FLValue_AsInt(FLValue);

    /** Returns a value coerced to an unsigned integer.
        This is the same as `FLValueAsInt` except that it _can't_ handle negative numbers, but
        does correctly return large `uint64_t` values of 2^63 and up. */
    uint64_t FLValue_AsUnsigned(FLValue);

    /** Returns a value coerced to a 32-bit floating point number. */
    float FLValue_AsFloat(FLValue);

    /** Returns a value coerced to a 64-bit floating point number. */
    double FLValue_AsDouble(FLValue);

    /** Returns the exact contents of a string value, or null for all other types. */
    FLString FLValue_AsString(FLValue);

    /** Returns the exact contents of a data value, or null for all other types. */
    FLSlice FLValue_AsData(FLValue);

    /** If a FLValue represents an array, returns it cast to FLArray, else NULL. */
    FLArray FLValue_AsArray(FLValue);

    /** If a FLValue represents a dictionary, returns it as an FLDict, else NULL. */
    FLDict FLValue_AsDict(FLValue);

    /** Returns a string representation of any scalar value. Data values are returned in raw form.
        Arrays and dictionaries don't have a representation and will return NULL. */
    FLStringResult FLValue_ToString(FLValue);

    /** Encodes a Fleece value as JSON (or a JSON fragment.) 
        Any Data values will become base64-encoded JSON strings. */
    FLStringResult FLValue_ToJSON(FLValue);

    /** Encodes a Fleece value as JSON5, a more lenient variant of JSON that allows dictionary
        keys to be unquoted if they're alphanumeric. This tends to be more readable. */
    FLStringResult FLValue_ToJSON5(FLValue v);

    /** Most general Fleece to JSON converter. */
    FLStringResult FLValue_ToJSONX(FLValue v,
                                  FLSharedKeys sk,
                                  bool json5,
                                  bool canonicalForm);


    /** Converts valid JSON5 to JSON. */
    FLStringResult FLJSON5_ToJSON(FLString json5, FLError *error);


    //////// ARRAY


    /** @} */
    /** \name Arrays
        @{ */

    /** Returns the number of items in an array, or 0 if the pointer is NULL. */
    uint32_t FLArray_Count(FLArray);

    /** Returns true if an array is empty. Slightly faster than `FLArray_Count(a) == 0` */
    bool FLArray_IsEmpty(FLArray);

    FLMutableArray FLArray_AsMutable(FLArray);

    /** Returns an value at an array index, or NULL if the index is out of range. */
    FLValue FLArray_Get(FLArray, uint32_t index);


    /** Opaque array iterator. Put one on the stack and pass its address to
        `FLArrayIteratorBegin`. */
    typedef struct {
        void* _private1;
        uint32_t _private2;
        bool _private3;
        void* _private4;
    } FLArrayIterator;

    /** Initializes a FLArrayIterator struct to iterate over an array.
        Call FLArrayIteratorGetValue to get the first item, then FLArrayIteratorNext. */
    void FLArrayIterator_Begin(FLArray, FLArrayIterator* FLNONNULL);

    /** Returns the current value being iterated over. */
    FLValue FLArrayIterator_GetValue(const FLArrayIterator* FLNONNULL);

    /** Returns a value in the array at the given offset from the current value. */
    FLValue FLArrayIterator_GetValueAt(const FLArrayIterator* FLNONNULL, uint32_t offset);

    /** Returns the number of items remaining to be iterated, including the current one. */
    uint32_t FLArrayIterator_GetCount(const FLArrayIterator* FLNONNULL);

    /** Advances the iterator to the next value, or returns false if at the end. */
    bool FLArrayIterator_Next(FLArrayIterator* FLNONNULL);


    //////// MUTABLE ARRAY

    FLMutableArray FLArray_MutableCopy(FLArray);

    FLMutableArray FLMutableArray_New(void);

    FLMutableArray FLMutableArray_Retain(FLMutableArray);
    void FLMutableArray_Release(FLMutableArray);

    FLArray FLMutableArray_GetSource(FLMutableArray);

    bool FLMutableArray_IsChanged(FLMutableArray);

    void FLMutableArray_AppendNull(FLMutableArray);
    void FLMutableArray_AppendBool(FLMutableArray, bool);
    void FLMutableArray_AppendInt(FLMutableArray, int64_t);
    void FLMutableArray_AppendUInt(FLMutableArray, uint64_t);
    void FLMutableArray_AppendFloat(FLMutableArray, float);
    void FLMutableArray_AppendDouble(FLMutableArray, double);
    void FLMutableArray_AppendString(FLMutableArray, FLString);
    void FLMutableArray_AppendData(FLMutableArray, FLSlice);
    void FLMutableArray_AppendValue(FLMutableArray, FLValue);

    void FLMutableArray_SetNull(FLMutableArray, uint32_t index);
    void FLMutableArray_SetBool(FLMutableArray, uint32_t index, bool);
    void FLMutableArray_SetInt(FLMutableArray, uint32_t index, int64_t);
    void FLMutableArray_SetUInt(FLMutableArray, uint32_t index, uint64_t);
    void FLMutableArray_SetFloat(FLMutableArray, uint32_t index, float);
    void FLMutableArray_SetDouble(FLMutableArray, uint32_t index, double);
    void FLMutableArray_SetString(FLMutableArray, uint32_t index, FLString);
    void FLMutableArray_SetData(FLMutableArray, uint32_t index, FLSlice);
    void FLMutableArray_SetValue(FLMutableArray, uint32_t index, FLValue);

    void FLMutableArray_Remove(FLMutableArray, uint32_t firstIndex, uint32_t count);
    void FLMutableArray_Resize(FLMutableArray, uint32_t size);

    FLMutableArray FLMutableArray_GetMutableArray(FLMutableArray, uint32_t index);
    FLMutableDict FLMutableArray_GetMutableDict(FLMutableArray, uint32_t index);
    

    //////// DICT


    /** @} */
    /** \name Dictionaries
        @{ */

    /** Returns the number of items in a dictionary, or 0 if the pointer is NULL. */
    uint32_t FLDict_Count(FLDict);

    /** Returns true if a dictionary is empty. Slightly faster than `FLDict_Count(a) == 0` */
    bool FLDict_IsEmpty(FLDict);

    FLMutableDict FLDict_AsMutable(FLDict);

    /** Looks up a key in a _sorted_ dictionary, returning its value.
        Returns NULL if the value is not found or if the dictionary is NULL. */
    FLValue FLDict_Get(FLDict, FLSlice keyString);

    /** Looks up a key in a _sorted_ dictionary, using a shared-keys mapping.
        If the database has a shared-keys mapping, you MUST use this call instead of FLDict_Get.
        Returns NULL if the value is not found or if the dictionary is NULL. */
    FLValue FLDict_GetSharedKey(FLDict d, FLSlice keyString, FLSharedKeys sk);
    
    /** Gets a string key from an FLSharedKeys object given its integer encoding 
        (for use when FLDictIterator_GetKey returns a value of type 'Number' */
    FLString FLSharedKey_GetKeyString(FLSharedKeys FLNONNULL sk, int keyCode, FLError* outError);


    /** Opaque dictionary iterator. Put one on the stack and pass its address to
        FLDictIterator_Begin. */
    typedef struct {
        void* _private1;
        uint32_t _private2;
        bool _private3;
        void* _private4[4];
        int _private5;
    } FLDictIterator;

    /** Initializes a FLDictIterator struct to iterate over a dictionary.
        Call FLDictIterator_GetKey and FLDictIterator_GetValue to get the first item,
        then FLDictIterator_Next. */
    void FLDictIterator_Begin(FLDict, FLDictIterator* FLNONNULL);

    /** Same as FLDictIterator_Begin but iterator will translate shared keys to strings. */
    void FLDictIterator_BeginShared(FLDict, FLDictIterator* FLNONNULL, FLSharedKeys);

    /** Returns the current key being iterated over. */
    FLValue FLDictIterator_GetKey(const FLDictIterator* FLNONNULL);

    /** Returns the current key's string value. */
    FLString FLDictIterator_GetKeyString(const FLDictIterator* FLNONNULL);

    /** Returns the current value being iterated over. */
    FLValue FLDictIterator_GetValue(const FLDictIterator* FLNONNULL);

    /** Returns the number of items remaining to be iterated, including the current one. */
    uint32_t FLDictIterator_GetCount(const FLDictIterator*  FLNONNULL);

    /** Advances the iterator to the next value, or returns false if at the end. */
    bool FLDictIterator_Next(FLDictIterator* FLNONNULL);

    /** Cleans up after an iterator. Only needed if (a) the dictionary is a delta, and
        (b) you stop iterating before the end (i.e. before FLDictIterator_Next returns false.) */
    void FLDictIterator_End(FLDictIterator* FLNONNULL);


    /** Opaque key for a dictionary. You are responsible for creating space for these; they can
        go on the stack, on the heap, inside other objects, anywhere. 
        Be aware that the lookup operations that use these will write into the struct to store
        "hints" that speed up future searches. */
    typedef struct {
        void* _private1[4];
        uint32_t _private2, private3;
        bool _private4, private5;
    } FLDictKey;

    /** Initializes an FLDictKey struct with a key string.
        Warning: the input string's memory MUST remain valid for as long as the FLDictKey is in
        use! (The FLDictKey stores a pointer to the string, but does not copy it.)
        @param string  The key string (UTF-8).
        @param cachePointers  If true, the FLDictKey is allowed to cache a direct Value pointer
                representation of the key. This provides faster lookup, but means that it can
                only ever be used with Dicts that live in the same stored data buffer.
        @return  The opaque key. */
    FLDictKey FLDictKey_Init(FLSlice string, bool cachePointers);

    FLDictKey FLDictKey_InitWithSharedKeys(FLSlice string, FLSharedKeys sharedKeys);

    /** Returns the string value of the key (which it was initialized with.) */
    FLString FLDictKey_GetString(const FLDictKey * FLNONNULL);

    /** Looks up a key in a dictionary using an FLDictKey. If the key is found, "hint" data will
        be stored inside the FLDictKey that will speed up subsequent lookups. */
    FLValue FLDict_GetWithKey(FLDict, FLDictKey* FLNONNULL);


    //////// MUTABLE DICT

    FLMutableDict FLDict_MutableCopy(FLDict);

    FLMutableDict FLMutableDict_New(void);

    FLMutableDict FLMutableDict_Retain(FLMutableDict);
    void FLMutableDict_Release(FLMutableDict);

    FLDict FLMutableDict_GetSource(FLMutableDict);

    bool FLMutableDict_IsChanged(FLMutableDict);

    void FLMutableDict_SetNull(FLMutableDict, FLString key);
    void FLMutableDict_SetBool(FLMutableDict, FLString key, bool);
    void FLMutableDict_SetInt(FLMutableDict, FLString key, int64_t);
    void FLMutableDict_SetUInt(FLMutableDict, FLString key, uint64_t);
    void FLMutableDict_SetFloat(FLMutableDict, FLString key, float);
    void FLMutableDict_SetDouble(FLMutableDict, FLString key, double);
    void FLMutableDict_SetString(FLMutableDict, FLString key, FLString);
    void FLMutableDict_SetData(FLMutableDict, FLString key, FLSlice);
    void FLMutableDict_SetValue(FLMutableDict, FLString key, FLValue);

    void FLMutableDict_Remove(FLMutableDict, FLString key);
    void FLMutableDict_RemoveAll(FLMutableDict);

    FLMutableArray FLMutableDict_GetMutableArray(FLMutableDict, FLString key);
    FLMutableDict FLMutableDict_GetMutableDict(FLMutableDict, FLString key);


    //////// DEEP ITERATOR


    /** Creates a FLDeepIterator to iterate over a dictionary.
        Call FLDeepIterator_GetKey and FLDeepIterator_GetValue to get the first item,
        then FLDeepIterator_Next. */
    FLDeepIterator FLDeepIterator_New(FLValue, FLSharedKeys);

    void FLDeepIterator_Free(FLDeepIterator);

    /** Returns the current value being iterated over. or NULL at the end of iteration. */
    FLValue FLDeepIterator_GetValue(FLDeepIterator FLNONNULL);

    /** Returns the key of the current value, or an empty slice if not in a dictionary. */
    FLSlice FLDeepIterator_GetKey(FLDeepIterator FLNONNULL);

    /** Returns the array index of the current value, or 0 if not in an array. */
    uint32_t FLDeepIterator_GetIndex(FLDeepIterator FLNONNULL);

    /** Returns the current depth in the hierarchy, starting at 1 for the top-level children. */
    size_t FLDeepIterator_GetDepth(FLDeepIterator FLNONNULL);

    /** Tells the iterator to skip the children of the current value. */
    void FLDeepIterator_SkipChildren(FLDeepIterator FLNONNULL);

    /** Advances the iterator to the next value, or returns false if at the end. */
    bool FLDeepIterator_Next(FLDeepIterator FLNONNULL);

    typedef struct {
        FLSlice key;        ///< Dict key, or kFLSliceNull if none
        uint32_t index;     ///< Array index, only if there's no key
    } FLPathComponent;

    /** Returns the path as an array of FLPathComponents. */
    void FLDeepIterator_GetPath(FLDeepIterator FLNONNULL,
                                FLPathComponent* * FLNONNULL outPath,
                                size_t* FLNONNULL outDepth);

    /** Returns the current path in JavaScript format. */
    FLSliceResult FLDeepIterator_GetPathString(FLDeepIterator FLNONNULL);

    /** Returns the current path in JSONPointer format (RFC 6901). */
    FLSliceResult FLDeepIterator_GetJSONPointer(FLDeepIterator FLNONNULL);

    //////// PATH


    /** Creates a new FLKeyPath object by compiling a path specifier string. */
    FLKeyPath FLKeyPath_New(FLSlice specifier, FLSharedKeys, FLError *error);

    /** Frees a compiled FLKeyPath object. (It's ok to pass NULL.) */
    void FLKeyPath_Free(FLKeyPath);

    /** Evaluates a compiled key-path for a given Fleece root object. */
    FLValue FLKeyPath_Eval(FLKeyPath FLNONNULL, FLValue root FLNONNULL);

    /** Evaluates a key-path from a specifier string, for a given Fleece root object.
        If you only need to evaluate the path once, this is a bit faster than creating an
        FLKeyPath object, evaluating, then freeing it. */
    FLValue FLKeyPath_EvalOnce(FLSlice specifier, FLSharedKeys, FLValue root FLNONNULL, FLError *error);


    //////// ENCODER


    /** @} */
    /** \name Encoder
        @{ */

    /** Creates a new encoder, for generating Fleece data. Call FLEncoder_Free when done. */
    FLEncoder FLEncoder_New(void);

    /** Creates a new encoder, allowing some options to be customized.
        @param format  The output format to generate (Fleece, JSON, or JSON5.)
        @param reserveSize  The number of bytes to preallocate for the output. (Default is 256)
        @param uniqueStrings  (Fleece only) If true, string values that appear multiple times will be written
            as a single shared value. This saves space but makes encoding slightly slower.
            You should only turn this off if you know you're going to be writing large numbers
            of non-repeated strings. Note also that the `cachePointers` option of FLDictKey
            will not work if `uniqueStrings` is off. (Default is true) */
    FLEncoder FLEncoder_NewWithOptions(FLEncoderFormat format,
                                       size_t reserveSize,
                                       bool uniqueStrings);

    /** Frees the space used by an encoder. */
    void FLEncoder_Free(FLEncoder);

    /** Tells the encoder to use a shared-keys mapping when encoding dictionary keys. */
    void FLEncoder_SetSharedKeys(FLEncoder FLNONNULL, FLSharedKeys);

    /** Associates an arbitrary user-defined value with the encoder. */
    void FLEncoder_SetExtraInfo(FLEncoder FLNONNULL, void *info);

    /** Returns the user-defined value associated with the encoder; NULL by default. */
    void* FLEncoder_GetExtraInfo(FLEncoder FLNONNULL);


    /** Tells the encoder to create a delta from the given Fleece document, instead of a standalone
        document. Any calls to FLEncoder_WriteValue() where the value points inside the base data
        will write a pointer back to the original value.
        The resulting data returned by FLEncoder_Finish() will *NOT* be standalone; it can only
        be used by first appending it to the base data.
        @param e  The FLEncoder affected.
        @param base  The base document to create a delta from.
        @param reuseStrings  If true, then writing a string that already exists in the base will
                    just create a pointer back to the original. But the encoder has to scan the
                    base for strings first.
        @param externPointers  If true, pointers into the base will be marked with the `extern`
                    flag. This allows them to be resolved using the `FLResolver_Begin` function,
                    so that when the delta is used the base document can be anywhere in memory,
                    not just immediately preceding the delta document. */
    void FLEncoder_MakeDelta(FLEncoder e FLNONNULL, FLSlice base,
                             bool reuseStrings, bool externPointers);

    /** Resets the state of an encoder without freeing it. It can then be reused to encode
        another value. */
    void FLEncoder_Reset(FLEncoder FLNONNULL);

    // Note: The functions that write to the encoder do not return error codes, just a 'false'
    // result on error. The actual error is attached to the encoder and can be accessed by calling
    // FLEncoder_GetError or FLEncoder_End.
    // After an error occurs, the encoder will ignore all subsequent writes.

    /** Writes a `null` value to an encoder. (This is an explicitly-stored null, like the JSON
        `null`, not the "undefined" value represented by a NULL FLValue pointer.) */
    bool FLEncoder_WriteNull(FLEncoder FLNONNULL);

    /** Writes a boolean value (true or false) to an encoder. */
    bool FLEncoder_WriteBool(FLEncoder FLNONNULL, bool);

    /** Writes an integer to an encoder. The parameter is typed as `int64_t` but you can pass any
        integral type (signed or unsigned) except for huge `uint64_t`s. */
    bool FLEncoder_WriteInt(FLEncoder FLNONNULL, int64_t);

    /** Writes an unsigned integer to an encoder. This function is only really necessary for huge
        64-bit integers greater than or equal to 2^63, which can't be represented as int64_t. */
    bool FLEncoder_WriteUInt(FLEncoder FLNONNULL, uint64_t);

    /** Writes a 32-bit floating point number to an encoder.
        (Note: as an implementation detail, if the number has no fractional part and can be
        represented exactly as an integer, it'll be encoded as an integer to save space. This is
        transparent to the reader, since if it requests the value as a float it'll be returned
        as floating-point.) */
    bool FLEncoder_WriteFloat(FLEncoder FLNONNULL, float);

    /** Writes a 64-bit floating point number to an encoder.
        (Note: as an implementation detail, if the number has no fractional part and can be
        represented exactly as an integer, it'll be encoded as an integer to save space. This is
        transparent to the reader, since if it requests the value as a float it'll be returned
        as floating-point.) */
    bool FLEncoder_WriteDouble(FLEncoder FLNONNULL, double);

    /** Writes a string to an encoder. The string must be UTF-8-encoded and must not contain any
        zero bytes.
        Do _not_ use this to write a dictionary key; use FLEncoder_WriteKey instead. */
    bool FLEncoder_WriteString(FLEncoder FLNONNULL, FLString);

    /** Writes a binary data value (a blob) to an encoder. This can contain absolutely anything
        including null bytes. Note that this data type has no JSON representation, so if the
        resulting value is ever encoded to JSON via FLValueToJSON, it will be transformed into
        a base64-encoded string.
        If the encoder is generating JSON, the blob will be written as a base64-encoded string. */
    bool FLEncoder_WriteData(FLEncoder FLNONNULL, FLSlice);

    /** Writes raw data to the encoded JSON output. 
        This can easily corrupt the output if you aren't careful!
        It will always fail with an error if the output format is Fleece. */
    bool FLEncoder_WriteRaw(FLEncoder FLNONNULL, FLSlice);


    /** Begins writing an array value to an encoder. This pushes a new state where each
        subsequent value written becomes an array item, until FLEncoder_EndArray is called.
        @param reserveCount  Number of array elements to reserve space for. If you know the size
            of the array, providing it here speeds up encoding slightly. If you don't know,
            just use zero. */
    bool FLEncoder_BeginArray(FLEncoder FLNONNULL, size_t reserveCount);

    /** Ends writing an array value; pops back the previous encoding state. */
    bool FLEncoder_EndArray(FLEncoder FLNONNULL);


    /** Begins writing a dictionary value to an encoder. This pushes a new state where each
        subsequent key and value written are added to the dictionary, until FLEncoder_EndDict is
        called.
        Before adding each value, you must call FLEncoder_WriteKey (_not_ FLEncoder_WriteString!),
        to write the dictionary key.
        @param reserveCount  Number of dictionary items to reserve space for. If you know the size
            of the dictionary, providing it here speeds up encoding slightly. If you don't know,
            just use zero. */
    bool FLEncoder_BeginDict(FLEncoder FLNONNULL, size_t reserveCount);

    /** Specifies the key for the next value to be written to the current dictionary. */
    bool FLEncoder_WriteKey(FLEncoder FLNONNULL, FLString);

    /** Ends writing a dictionary value; pops back the previous encoding state. */
    bool FLEncoder_EndDict(FLEncoder FLNONNULL);


    /** Writes a Fleece Value to an Encoder. */
    bool FLEncoder_WriteValue(FLEncoder FLNONNULL, FLValue FLNONNULL);

    /** Writes a Fleece Value that uses SharedKeys to an Encoder. */
    bool FLEncoder_WriteValueWithSharedKeys(FLEncoder FLNONNULL, FLValue FLNONNULL, FLSharedKeys);


    /** Parses JSON data and writes the object(s) to the encoder. (This acts as a single write,
        like WriteInt; it's just that the value written is likely to be an entire dictionary of
        array.) */
    bool FLEncoder_ConvertJSON(FLEncoder FLNONNULL, FLSlice json);


    /** Returns the number of bytes encoded so far. */
    size_t FLEncoder_BytesWritten(FLEncoder FLNONNULL);

    /** Ends encoding; if there has been no error, it returns the encoded data, else null.
        This does not free the FLEncoder; call FLEncoder_Free (or FLEncoder_Reset) next. */
    FLSliceResult FLEncoder_Finish(FLEncoder FLNONNULL, FLError*);

    /** Returns the error code of an encoder, or NoError (0) if there's no error. */
    FLError FLEncoder_GetError(FLEncoder FLNONNULL);

    /** Returns the error message of an encoder, or NULL if there's no error. */
    const char* FLEncoder_GetErrorMessage(FLEncoder FLNONNULL);


    //////// RESOLVER


    /** @} */
    /** \name Extern Resolver
     @{ */

    /** Indicates that external pointers in `document` (that is, pointers that point outside the
        document) should be resolved to point into `destination`. This mapping remains in effect
        until `FLResolver_End` is called on the same `document`. */
    void FLResolver_Begin(FLSlice document, FLSlice destination);

    /** Ends external pointer resolution from the memory range of `document`. This must be called
        before that memory is invalidated (freed or overwritten.) */
    void FLResolver_End(FLSlice document);


    //////// JSON DELTA COMPRESSION


    /** @} */
    /** \name Delta Compression
     @{ */

    /** Returns JSON that encodes the changes to turn the value `old` into `nuu`;
        or if the values are equal, returns a null slice.
        (The format is documented in Fleece.md, but you should treat it as a black box.)
        @param old  A value that's typically the old/original state of some data.
        @param nuu  A value that's typically the new/changed state of the `old` data.
        @return  JSON data representing the changes from `old` to `nuu`. */
    FLSliceResult FLCreateDelta(FLValue old, FLSharedKeys oldSK,
                                FLValue nuu, FLSharedKeys nuuSK);

    /** Writes JSON that describes the changes to turn the value `old` into `nuu`.
        If the values are equal, writes nothing and returns false.
        (The format is documented in Fleece.md, but you should treat it as a black box.)
        @param old  A value that's typically the old/original state of some data.
        @param nuu  A value that's typically the new/changed state of the `old` data.
        @param jsonEncoder  An encoder to write the JSON to. Must have been created using
                `FLEncoder_NewWithOptions`, with JSON or JSON5 format.
        @return  True if a delta was encoded, or false if the values are equal. */
    bool FLEncodeDelta(FLValue old, FLSharedKeys oldSK,
                       FLValue nuu, FLSharedKeys nuuSK,
                       FLEncoder FLNONNULL jsonEncoder);


    /** Applies the JSON data created by `CreateDelta` to the value `old`, which must be equal
        to the `old` value originally passed to `FLCreateDelta`, and returns a Fleece document
        equal to the original `nuu` value.
        @param old  A value that's typically the old/original state of some data. This must be
                    equal to the `old` value used when creating the `jsonDelta`.
        @param jsonDelta  A JSON-encoded delta created by `FLCreateDelta` or `FLEncodeDelta`.
        @param error  On failure, error information will be stored where this points, if non-null.
        @return  The corresponding `nuu` value, encoded as Fleece, or null if an error occurred. */
    FLSliceResult FLApplyDelta(FLValue old,
                               FLSharedKeys sk,
                               FLSlice jsonDelta,
                               FLError *error);

    /** Applies the (parsed) JSON data created by `CreateDelta` to the value `old`, which must be
        equal to the `old` value originally passed to `FLCreateDelta`, and writes the corresponding
        `nuu` value to the encoder.
        @param old  A value that's typically the old/original state of some data. This must be
                    equal to the `old` value used when creating the `jsonDelta`.
        @param jsonDelta  A JSON-encoded delta created by `FLCreateDelta` or `FLEncodeDelta`.
        @param encoder  A Fleece encoder to write the decoded `nuu` value to. (JSON encoding is not
                    supported.)
        @return  True on success, false on error; call `FLEncoder_GetError` for details. */
    bool FLEncodeApplyingDelta(FLValue old,
                               FLSharedKeys sk,
                               FLValue FLNONNULL jsonDelta,
                               FLEncoder encoder);

    
    /** @} */
    /** @} */

#ifdef __cplusplus
}
#endif


#ifdef __OBJC__
// Include Obj-C/CF utilities:
#include "Fleece+CoreFoundation.h"
#endif


#ifdef __cplusplus
// Now include the C++ convenience wrapper:
#include "FleeceCpp.hh"
#endif

#endif // _FLEECE_H
