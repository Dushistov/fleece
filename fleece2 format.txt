// Fleece2

Goals:

* No parsing necessary before using data (unless you want to validate)
* No memory allocation needed -- you can use pointers directly into the data
* Can represent anything JSON can, hopefully with bonuses (binary data)
* Avoid repeating strings
* Smaller than JSON

A file consists of Values. 
A basic value is 2 bytes, although some types are longer.
One type of value is a pointer, which contains an offset to another value.
Pointers are automatically dereferenced (like symlinks) so any value can be fit into 2 bytes by
replacing it with a pointer. (This is important because arrays and dictionaries contain only
2-byte values, for random access.)

A basic 2-byte value can store:
    null, true, false, integers -2048..2047, empty or 1-byte string, empty or 1-byte binary data,
    empty array, empty dictionary.

Pointers have a relative range of ±32k bytes, but pointers can point to pointers...


Value binary layout:

0000ssss --------       special (null, false, true)
0001iiii iiiiiiii       small integer (12-bit, signed, range ±2048)
0010uccc iiiiiiii...    long integer (u=unsigned?; ccc is byte count - 1)
0011cccc 00000000       floating point (cccc is byte count, always 4 or 8). Float data follows.
0100cccc ssssssss...    string (cccc is byte count, or if 15 then count follows as varint)
0101cccc dddddddd...    binary data (same as string)
0110cccc cccccccc       array (c is 12-bit item count, if 4095 then count follows as varint)
0111cccc cccccccc       dictionary (ditto)
1ooooooo oooooooo       pointer (o is signed offset in units of 2 bytes: ±32k bytes)


Array:
    0110cccc cccccccc
    Value #0
    Value #1
    ...

Dictionary:
0111cccc cccccccc       dictionary (ditto)
Key #0
Key #1
...
Value #0
Value #1


EXAMPLE:

{"foo": 123}

00: 70 01                   # dictionary, count=1
02: 10 04                   # Pointer to string "foo"
04: 10 7B                   # integer 123
06: 43 f  o  o              # string "foo"
0A:

10 bytes … vs 11 for JSON!
